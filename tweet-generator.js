const fs = require("fs");
const path = require("path");
const { GoogleGenAI } = require("@google/genai");
const axios = require("axios");
require("dotenv").config();

// Initialize Gemini AI
const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// Get current trending topics (without needing browser automation)
async function getTrendingTopics() {
  try {
    // Using public APIs is unreliable without auth, so we'll use fallback topics
    const fallbackTopics = [
      "Technology",
      "Web Development",
      "JavaScript",
      "Artificial Intelligence",
      "Machine Learning",
      "React",
      "Node.js",
      "Python",
      "Cloud Computing",
    ];

    return fallbackTopics;
  } catch (err) {
    console.log("Could not fetch trends, using defaults");
    return [
      "Technology",
      "Web Development",
      "JavaScript",
      "Artificial Intelligence",
      "Machine Learning",
    ];
  }
}

// Generate tweet based on trends
async function generateTweet(topics) {
  try {
    const trendsList = topics.join(", ");
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash",
      contents: `Generate an insightful tweet about one of these topics: ${trendsList}.
      
      - Within 280 characters
      - Informative and engaging
      - Include 1-2 relevant hashtags
      - Relate to current events or technology
      - Only output the tweet text, no additional context`,
    });
    console.log("Full response:", response); // Log the entire response structure

    // Adjust this line based on the logged structure
    return response.candidates[0].content.parts[0].text.trim();
  } catch (error) {
    console.error("Error generating tweet:", error);

    // Fallback tweet if AI fails
    return `Exploring the latest in ${
      topics[0]
    } today. Always amazed by the rapid innovations in this field! #${topics[0].replace(
      /\s+/g,
      ""
    )} #TechTrends`;
  }
}

// Save tweet to markdown file
async function saveTweet(tweet) {
  const filePath = path.join(__dirname, "generated-tweets.md");
  const date = new Date().toISOString().replace("T", " ").substring(0, 19);

  let content = "";
  try {
    if (fs.existsSync(filePath)) {
      content = fs.readFileSync(filePath, "utf8");
    } else {
      content =
        "# Generated Tweets\n\nTweets generated by AI for easy posting.\n\n";
    }
  } catch (err) {
    content =
      "# Generated Tweets\n\nTweets generated by AI for easy posting.\n\n";
  }

  // Add new tweet at the top
  const tweetEntry = `## ${date}\n\n${tweet}\n\n[Click to post this tweet](https://twitter.com/intent/tweet?text=${encodeURIComponent(
    tweet
  )})\n\n---\n\n`;
  content = content.replace(
    "# Generated Tweets\n\nTweets generated by AI for easy posting.\n\n",
    `# Generated Tweets\n\nTweets generated by AI for easy posting.\n\n${tweetEntry}`
  );

  fs.writeFileSync(filePath, content);
  console.log("Tweet saved to generated-tweets.md");
}

// Save tweet for Buffer (outputs CSV)
async function saveTweetForBuffer(tweet) {
  const filePath = path.join(__dirname, "buffer-tweets.csv");
  const date = new Date();

  // Schedule for tomorrow at random hour
  date.setDate(date.getDate() + 1);
  date.setHours(Math.floor(Math.random() * 12) + 8); // Random hour between 8am-8pm

  const scheduledTime = date.toISOString();

  // Buffer CSV format: Text, Schedule
  const csvLine = `"${tweet.replace(/"/g, '""')}","${scheduledTime}"\n`;

  // Create or append to CSV file
  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, "Text,Schedule\n");
  }

  fs.appendFileSync(filePath, csvLine);
  console.log("Tweet saved for Buffer import");
}

// Post to IFTTT if key exists - NOTE: Twitter/X integration no longer available in free tier
async function postToIFTTT(tweet) {
  try {
    // You'll need your IFTTT webhook key
    const webhookKey = process.env.IFTTT_KEY || "";
    const eventName = "new_tweet"; // Your IFTTT event name

    if (!webhookKey) {
      console.log("IFTTT key not found in .env file");
      return;
    }

    console.log(
      "NOTE: IFTTT no longer supports Twitter/X posting in free tier"
    );
    console.log("This webhook may still be useful for other services");

    // Post to IFTTT webhook
    const response = await axios.post(
      `https://maker.ifttt.com/trigger/${eventName}/with/key/${webhookKey}`,
      {
        value1: tweet,
      }
    );

    console.log("Tweet sent to IFTTT webhook");
    return true;
  } catch (error) {
    console.error("Error posting to IFTTT:", error);
    return false;
  }
}

// Post to Make.com webhook
async function postToMake(tweet) {
  try {
    const webhookUrl = process.env.MAKE_WEBHOOK_URL;

    if (!webhookUrl) {
      console.log("Make.com webhook URL not found in .env file");
      return false;
    }

    // Send tweet to Make.com webhook
    const response = await axios.post(webhookUrl, {
      tweet_text: tweet,
      timestamp: new Date().toISOString(),
      source: "AI Tweet Generator",
    });

    console.log("Tweet sent to Make.com for posting");
    return true;
  } catch (error) {
    console.error("Error posting to Make.com:", error.message);
    if (error.response && error.response.data) {
      console.error("Response data:", error.response.data);
    }
    return false;
  }
}

// Main function
async function main() {
  const topics = await getTrendingTopics();
  console.log("Topics:", topics);

  const tweet = await generateTweet(topics);
  console.log("Generated tweet:", tweet);

  // Always save locally
  await saveTweet(tweet);
  await saveTweetForBuffer(tweet);

  // Try posting via Make.com if configured
  if (process.env.MAKE_WEBHOOK_URL) {
    await postToMake(tweet);
  }

  // Try optional services if configured
  if (process.env.IFTTT_KEY) {
    console.log("Note: IFTTT no longer supports Twitter/X in free plan");
    await postToIFTTT(tweet);
  }
}

main().catch(console.error);
